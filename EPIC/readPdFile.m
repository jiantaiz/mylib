function [wavegen, wmem, header ] = readPdFile(fname)
% READPDFILE parses .pd binary file (generated by GE WTOOLS) according to how it was written by PDStoreData.c
%    [wavegen, wmem, header ] = READPDFILE(fname) 
%       INPUTS:
%          fname : pulse database file name (.pd, .pdx)
%       OUTPUTS:
%          wavegen : structure array for all waveform generators; containing instruction tables
%                    wavegen.name : names of wave generators (X Grad, Y
%                    Grad, Z Grad, Rho 1, Rho 2, Theta, Omega, or SSP, Aux)
%                    wavegen.dsp_index : DSP index
%                    wavegen.inst_tab : instruction table [wmem_idx, period, amplitude]
%          wmem : 1x2 cell array, waveform memory for the 2 DSPs
%          header : header info
%    See also: plotPdFile

% AUTHOR    : Yi Sui
% DATE      : 05/16/2016

fp = fopen(fname);
header = [];
for k = 1:10
    header =[ header, readString(fp)];
end

num_wavegen = fread(fp,1,'int32'); % number of wave generators. Instruction mem sits in Wave Generators
num_dsp = fread(fp,1,'int32'); % number of DSP. Waveform mem sits in DSP

for k = 1:num_wavegen
    %names of wave generators. X Grad, Y Grad, Z Grad, Rho 1, Rho 2, Theta, Omega, SSP, Aux
    gen_name{k} = readString(fp); 
    
    % current wave generator number = k-1
    n32_datum = fread(fp,1,'int32');
    
    %/* This array maps the waveform generators to a DSP */
    % const n16 seq_dsp_index[NUM_WAVEGEN] = {0,  /* x grad handled by dsp 0 */
    %                                    0,  /* y grad */
    %                                    0,  /* z grad */
    %                                    1,  /* rho 1 handled by dsp 1 */
    %                                    1,  /* rho 2 */
    %                                    1,  /* theta */
    %                                    1,  /* omega */
    %                                    0,  /* ssp */
    %                                    0 };/* aux */
    seq_dsp_index(k) = fread(fp,1,'int32');
end

%read in waveform memory for each dsp
for k =1:num_dsp
    %for the defination of variables, refer to <ESE_TOP>/mgd/agp/pgen/include/pgen_globals.h 
    wave_base_ptr(k) = fread(fp,1,'*uint32'); %Points to base of wave memory
    wp_count(k) = fread(fp,1,'*uint32'); % A count of wavepoints loaded 
    
    max_wp(k) = fread(fp,1,'*uint32'); %Maximum number of wavepoints allowed 
    wmem{k} = fread(fp,wp_count(k),'int16' ); %wave memory
end

%read in instruction memory
for k = 1:num_wavegen
    
    pointer_datum_wv(k) = fread(fp,1,'int32'); %Points to base of instructions
    inst_count(k) = fread(fp,1,'int32'); %A count of instructions loaded
    max_inst(k) = fread(fp,1,'int32'); %Maximum number of instructions allowed 
    imem=[];
    for j = 1:inst_count(k)
        imem(j).period = fread(fp,1,'*uint32');  %period of each waveform point
        imem(j).waveform = fread(fp,1,'*uint32');%address of waveform in the waveform memory
        amplitude = fread(fp,1,'*uint32'); %waveform amplitude,the highest bit is EOS(end of sequence) bit, lower 31-bit is signed integer
        if (bitget(amplitude, 32) == 1) %EOS 
            amplitude = intmax('int32'); %
        else
            amplitude = typecast(amplitude.*2,'int32') ./ 2; % discard the highest bit, then cast from uint32 to int32  
        end
        imem(j).amplitude = double (amplitude);
    end
    imems{k} = imem;
end
fclose(fp);

%orgnize into instruction table
for k = 1:num_wavegen
   
   dsp_idx = seq_dsp_index(k) + 1;
   wavegen(k).name = gen_name{k};
   wavegen(k).dsp_index = dsp_idx;
   
   if ~isempty(imems{k})
        wave_idx = ([imems{k}.waveform] - wave_base_ptr(dsp_idx)) / 2 + 1; % each wavepoint has two bytes (16-bit)
        period = [imems{k}.period];
        amp = [imems{k}.amplitude];
        wavegen(k).inst_tab = [double(wave_idx'), double(period'), double(amp')];
   else
        wavegen(k).inst_tab = [];
   end
end
